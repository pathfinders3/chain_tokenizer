<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Block Move Solver Output</title>
    <link rel="icon" type="image/png" href="blockMove.png">
    <style>
        body {
            font-family: monospace;
            margin: 20px;
            background-color: #1e1e1e;
            color: #ffffff;
        }
        h1 {
            color: #ffffff;
        }
        textarea {
            width: 100%;
            height: 600px;
            font-family: 'Courier New', Courier, monospace;
            font-size: 14px;
            line-height: 1.2;
            background-color: #2d2d2d;
            color: #ffffff;
            border: 1px solid #444;
            padding: 10px;
            resize: vertical;
            white-space: pre;
        }
        select {
            background-color: #2d2d2d;
            color: #ffffff;
            border: 1px solid #444;
            padding: 5px;
            font-family: monospace;
            font-size: 14px;
        }
        option {
            background-color: #2d2d2d;
            color: #ffffff;
        }
    </style>
</head>
<body>
    <h1>Block Move Solver Output</h1>
    <div id="inputCanvasContainer" style="margin-bottom: 20px;">
        <p>ì´ë¯¸ì§€ë¥¼ ë¶™ì—¬ë„£ìœ¼ë ¤ë©´ ì•„ë˜ ìº”ë²„ìŠ¤ì— CTRL-Vë¥¼ ì‚¬ìš©í•˜ì„¸ìš”. ì‹œì‘ ìœ„ì¹˜ë¥¼ ì§€ì •í•˜ë ¤ë©´ ìº”ë²„ìŠ¤ë¥¼ í´ë¦­í•˜ì„¸ìš”:</p>
        <canvas id="inputCanvas" width="400" height="400" style="border: 1px solid #444; cursor: crosshair;"></canvas>
        <div style="margin-top: 10px;">
            <label for="gridSizeSelect">ê·¸ë¦¬ë“œ í¬ê¸° ì„ íƒ:</label>
            <select id="gridSizeSelect">
                <option value="8">8x8</option>
                <option value="16">16x16</option>
            </select>
            <button id="loadGridFromImage">ì´ë¯¸ì§€ì—ì„œ ê·¸ë¦¬ë“œ ë¡œë“œ</button>
            <button id="startTileCalculation" style="display: none;">íƒ€ì¼ ê³„ì‚° ì‹œì‘</button>
            <label for="startPositionSelect">ì²« íƒ€ì¼ ìœ„ì¹˜:</label>
            <select id="startPositionSelect">
                <option value="topLeft">Top-Left</option>
                <option value="topRight">Top-Right</option>
                <option value="custom">Custom</option>
            </select>
            <span id="customStartTile" style="display: none;">
                <label for="startTileR">Row:</label>
                <input type="number" id="startTileR" min="0" value="0" style="width: 60px;">
                <label for="startTileC">Column:</label>
                <input type="number" id="startTileC" min="0" value="1" style="width: 60px;">
            </span>
            <label for="startAngleSelect">ì‹œì‘ ê°ë„(ë°©í–¥):</label>
            <select id="startAngleSelect">
                <option value="0">â†’ (0Â°, ì˜¤ë¥¸ìª½)</option>
                <option value="45">â†— (45Â°, ì˜¤ë¥¸ìª½ ìœ„)</option>
                <option value="90">â†‘ (90Â°, ìœ„)</option>
                <option value="135">â†– (135Â°, ì™¼ìª½ ìœ„)</option>
                <option value="180">â† (180Â°, ì™¼ìª½)</option>
                <option value="225">â†™ (225Â°, ì™¼ìª½ ì•„ë˜)</option>
                <option value="270">â†“ (270Â°, ì•„ë˜)</option>
                <option value="315">â†˜ (315Â°, ì˜¤ë¥¸ìª½ ì•„ë˜)</option>
            </select>
            <label for="tileSizeSelect">íƒ€ì¼ í¬ê¸°:</label>
            <select id="tileSizeSelect">
                <option value="2">2x2</option>
                <option value="3">3x3</option>
            </select>
        </div>
        <p id="gridLoadStatus"></p>
        <p id="calculationStatus" style="font-weight: bold; color: #ffff00; display: none;">ê³„ì‚° ì§„í–‰ ì¤‘ì…ë‹ˆë‹¤. ì ì‹œë§Œ ê¸°ë‹¤ë ¤ ì£¼ì„¸ìš”...</p>
    </div>
    <textarea id="output" readonly>
        ê³„ì‚° ì¤‘ì…ë‹ˆë‹¤. ì ì‹œë§Œ ê¸°ë‹¤ë ¤ ì£¼ì„¸ìš”...
    </textarea>
    <div id="inputSection" style="margin-top: 20px;">
        <label for="tileSelect">ë‹¤ìŒ íƒ€ì¼ì„ ì„ íƒí•˜ì„¸ìš”:</label>
        <span id="currentTileInfo" style="margin-left: 10px; font-weight: bold; color: #ffff00;">í˜„ì¬ íƒ€ì¼: ì—†ìŒ</span>
        <br>
        <div id="tilePath" style="margin: 10px 0; padding: 10px; background-color: #2d2d2d; border: 1px solid #444; min-height: 30px;">
            <div style="font-size: 12px; color: #aaaaaa; margin-bottom: 5px;">ì—°ê²°ëœ íƒ€ì¼ ê²½ë¡œ (í´ë¦­í•˜ì—¬ í•´ë‹¹ íƒ€ì¼ë¶€í„° ì‚­ì œ):</div>
            <div id="tilePathItems" style="display: flex; flex-wrap: wrap; gap: 5px;"></div>
        </div>
        <select id="tileSelect">
            <option value="">-- ì„ íƒ --</option>
        </select>
        <button id="selectTile">ì„ íƒ</button>
        <button id="autoSelect">ìë™ì„ íƒ</button>
        <button id="stopSelection">ì¤‘ì§€</button>
    </div>
    <div id="canvasContainer" style="margin-top: 20px; display: none;">
        <canvas id="resultCanvas" style="border: 1px solid #444;"></canvas>
        <p>ê²°ê³¼ ì´ë¯¸ì§€ê°€ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤. í´ë¦½ë³´ë“œì— ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤.</p>
    </div>

    <!-- íƒ€ì¼ ê·¸ë£¹í•‘ ê²°ê³¼ ì„¹ì…˜ -->
    <div id="groupingSection" style="margin-top: 30px; display: none;">
        <h2 style="color: #ffffff; border-bottom: 2px solid #444; padding-bottom: 10px;">íƒ€ì¼ ê·¸ë£¹í•‘ ê²°ê³¼</h2>
        <div style="margin-bottom: 15px;">
            <label for="angleThresholdInput">ê°ë„ ì„ê³„ê°’ (ë„):</label>
            <input type="number" id="angleThresholdInput" min="5" max="180" step="5" value="45" 
                   style="width: 80px; background-color: #2d2d2d; color: #ffffff; border: 1px solid #444; padding: 5px; margin-left: 10px;">
            <button id="regroupButton" style="margin-left: 10px; padding: 5px 15px; background-color: #4a4a4a; color: #ffffff; border: 1px solid #666; cursor: pointer;">
                ë‹¤ì‹œ ê·¸ë£¹í•‘
            </button>
            <button id="copyToClipboard" style="margin-left: 10px; padding: 5px 15px; background-color: #0066cc; color: #ffffff; border: 1px solid #0055aa; cursor: pointer; font-weight: bold;">
                ğŸ“‹ í´ë¦½ë³´ë“œì— ë³µì‚¬
            </button>
            <span style="margin-left: 15px; color: #aaaaaa; font-size: 12px;">
                (ê°ë„ ì°¨ì´ê°€ ì„ê³„ê°’ì„ ì´ˆê³¼í•˜ë©´ ìƒˆë¡œìš´ ê·¸ë£¹ìœ¼ë¡œ ë¶„ë¦¬ë©ë‹ˆë‹¤)
            </span>
        </div>
        <div id="groupsDisplay" style="background-color: #2d2d2d; border: 1px solid #444; padding: 15px; border-radius: 5px;">
            <!-- ê·¸ë£¹ ì •ë³´ê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤ -->
        </div>
    </div>

    <script>
        // ì½˜ì†” ì¶œë ¥ì„ textareaì— ë¦¬ë‹¤ì´ë ‰íŠ¸
        const outputElement = document.getElementById('output');
        let outputText = '';

        // ì½˜ì†” ë©”ì„œë“œ ì˜¤ë²„ë¼ì´ë“œ
        function redirectConsole(method, prefix = '') {
            const original = console[method];
            console[method] = function(...args) {
                outputText += prefix + args.join(' ') + '\n';
                outputElement.value = outputText;
                outputElement.scrollTop = outputElement.scrollHeight;
                original.apply(console, args);
            };
        }
        
        redirectConsole('log');
        redirectConsole('error', 'ERROR: ');
        redirectConsole('warn', 'WARN: ');

        // íƒ€ì¼ ì„ íƒ ê²°ê³¼ë¥¼ ê´€ë¦¬í•˜ëŠ” í´ë¡œì € íŒ¨í„´
        const TileResultManager = (() => {
            let result = null;
            
            return {
                // ê²°ê³¼ ì €ì¥
                save: (data) => {
                    if (!data) {
                        console.warn('[TileResultManager] Invalid data provided');
                        return false;
                    }
                    result = data;
                    console.log(`[TileResultManager] âœ“ Saved: ${data.orderedTiles?.length || 0} tiles, ${data.groups?.length || 0} groups`);
                    return true;
                },
                
                // ì „ì²´ ê²°ê³¼ ë°˜í™˜
                get: () => result,
                
                // íƒ€ì¼ ë°°ì—´ë§Œ ë°˜í™˜
                getTiles: () => result?.orderedTiles || [],
                
                // ê·¸ë£¹ ë°°ì—´ë§Œ ë°˜í™˜
                getGroups: () => result?.groups || [],
                
                // ìƒíƒœ ì •ë³´ ë°˜í™˜
                getState: () => result?.state,
                
                // ê²°ê³¼ ì¡´ì¬ ì—¬ë¶€
                hasResult: () => result !== null,
                
                // ê²°ê³¼ ì‚­ì œ
                clear: () => {
                    result = null;
                    console.log('[TileResultManager] Cleared');
                }
            };
        })();
        
        // ì „ì—­ìœ¼ë¡œ ë…¸ì¶œ (ì½˜ì†”ì—ì„œë„ ì ‘ê·¼ ê°€ëŠ¥)
        window.TileResultManager = TileResultManager;

        // ì‚¬ìš©ì ì…ë ¥ ì²˜ë¦¬ë¥¼ ìœ„í•œ ì „ì—­ ë³€ìˆ˜
        let userInputResolver = null;
        const tileSelect = document.getElementById('tileSelect');
        const selectTileButton = document.getElementById('selectTile');
        const stopSelectionButton = document.getElementById('stopSelection');
        const inputSection = document.getElementById('inputSection');
        const tilePathItems = document.getElementById('tilePathItems');
        
        // íƒ€ì¼ ê²½ë¡œë¥¼ ì €ì¥í•˜ëŠ” ë°°ì—´
        let currentTilePath = [];

        // ì…ë ¥ ì„¹ì…˜ í‘œì‹œ/ìˆ¨ê¹€
        function showInputSection(show) {
            inputSection.style.display = show ? 'block' : 'none';
        }
        
        // íƒ€ì¼ ê²½ë¡œ ì—…ë°ì´íŠ¸
        function updateTilePath(tiles) {
            currentTilePath = tiles.slice();
            tilePathItems.innerHTML = '';
            
            if (tiles.length === 0) {
                tilePathItems.innerHTML = '<span style="color: #aaaaaa;">íƒ€ì¼ ì—†ìŒ</span>';
                return;
            }
            
            tiles.forEach((tile, index) => {
                const tileButton = document.createElement('button');
                tileButton.textContent = String.fromCharCode(65 + (index % 26)); // A, B, C, ...
                tileButton.title = `(${tile.r}, ${tile.c}) - í´ë¦­í•˜ì—¬ ì´ íƒ€ì¼ë¶€í„° ì‚­ì œ`;
                tileButton.style.cssText = `
                    padding: 5px 10px;
                    background-color: #4a4a4a;
                    color: #ffffff;
                    border: 1px solid #666;
                    border-radius: 3px;
                    cursor: pointer;
                    font-weight: bold;
                `;
                
                tileButton.addEventListener('mouseenter', () => {
                    tileButton.style.backgroundColor = '#ff6666';
                });
                
                tileButton.addEventListener('mouseleave', () => {
                    tileButton.style.backgroundColor = '#4a4a4a';
                });
                
                tileButton.addEventListener('click', () => {
                    removeTilesFrom(index);
                });
                
                tilePathItems.appendChild(tileButton);
                
                // ë§ˆì§€ë§‰ íƒ€ì¼ì´ ì•„ë‹ˆë©´ í™”ì‚´í‘œ ì¶”ê°€
                if (index < tiles.length - 1) {
                    const arrow = document.createElement('span');
                    arrow.textContent = 'â†’';
                    arrow.style.cssText = 'color: #aaaaaa; margin: 0 2px;';
                    tilePathItems.appendChild(arrow);
                }
            });
        }
        
        // íŠ¹ì • ì¸ë±ìŠ¤ë¶€í„° íƒ€ì¼ ì‚­ì œ
        function removeTilesFrom(index) {
            if (typeof window.removeTilesFromPath === 'function') {
                window.removeTilesFromPath(index);
            } else {
                console.error('removeTilesFromPath function not available');
            }
        }
        
        // ì „ì—­ìœ¼ë¡œ ë…¸ì¶œ
        window.updateTilePath = updateTilePath;
        window.showInputSection = showInputSection;

        // ê°ë„ë¥¼ í™”ì‚´í‘œë¡œ ë³€í™˜í•˜ëŠ” í•¨ìˆ˜
        function getArrowFromAngle(deg) {
            const dirs = [
                { a: 0,   ch: "â†’" },
                { a: 45,  ch: "â†—" },
                { a: 90,  ch: "â†‘" },
                { a: 135, ch: "â†–" },
                { a: 180, ch: "â†" },
                { a: 225, ch: "â†™" },
                { a: 270, ch: "â†“" },
                { a: 315, ch: "â†˜" },
            ];
            let best = dirs[0];
            let bestDiff = 1e9;
            for (const d of dirs) {
                let diff = Math.abs(deg - d.a);
                diff = Math.min(diff, 360 - diff);
                if (diff < bestDiff) { bestDiff = diff; best = d; }
            }
            return best.ch;
        }

        // íƒ€ì¼ ì„ íƒ ì˜µì…˜ ì—…ë°ì´íŠ¸
        function createTileOption(index, text, color = null) {
            const option = document.createElement('option');
            option.value = index;
            option.textContent = text;
            if (color) option.style.color = color;
            return option;
        }
        
        function updateTileOptions(candidates, tiles, cur, centers, k, prevAngle, adjacentCandidates = []) {
            tileSelect.innerHTML = '';
            
            // '-- ì„ íƒ --' ì˜µì…˜ ìƒì„±
            const defaultOption = document.createElement('option');
            defaultOption.value = '';
            
            // ì„ íƒ ê°€ëŠ¥í•œ íƒ€ì¼ì´ 1ê°œë§Œ ìˆìœ¼ë©´ ë¶‰ì€ìƒ‰ìœ¼ë¡œ í‘œì‹œí•˜ê³  í‘œì‹ ì¶”ê°€
            if (adjacentCandidates?.length === 1) {
                defaultOption.textContent = 'â“µ -- ì„ íƒ --';
                defaultOption.style.color = '#ff0000';
                // select ìš”ì†Œ ìì²´ë„ ë¶‰ì€ìƒ‰ìœ¼ë¡œ ë³€ê²½ (ë‹«í˜€ìˆì„ ë•Œ ë³´ì´ë„ë¡)
                tileSelect.style.color = '#ff0000';
            } else {
                defaultOption.textContent = '-- ì„ íƒ --';
                // select ìš”ì†Œ ìƒ‰ìƒì„ ê¸°ë³¸ê°’ìœ¼ë¡œ ë³µì›
                tileSelect.style.color = '';
            }
            
            tileSelect.appendChild(defaultOption);
            
            // textareaì— í‘œì‹œí•  í…ìŠ¤íŠ¸ ì¤€ë¹„
            let textareaInfo = `\n`;
            
            // íƒ€ì¼ì´ ìˆëŠ” ê²½ìš° ê°•ì¡° í‘œì‹œ
            if (adjacentCandidates?.length >= 1) {
                textareaInfo += `${'='.repeat(50)}\n`;
                textareaInfo += `*** ì£¼ì˜: ì„ íƒ ê°€ëŠ¥í•œ íƒ€ì¼ì´ ${adjacentCandidates.length}ê°œ ìˆìŠµë‹ˆë‹¤! ***\n`;
                textareaInfo += `${'='.repeat(50)}\n`;
            }
            
            textareaInfo += `Available adjacent tiles:\n`;
            
            // ì¸ì ‘ íƒ€ì¼ ì¶”ê°€
            if (adjacentCandidates?.length > 0) {
                adjacentCandidates.forEach((adjTile, index) => {
                    let text = `${index}. (${adjTile.r}, ${adjTile.c})`;
                    let angleInfo = '';
                    
                    // ê°ë„ ì •ë³´ê°€ ìˆìœ¼ë©´ ì¶”ê°€
                    if (adjTile.angle !== undefined) {
                        const arrow = getArrowFromAngle(adjTile.angle);
                        angleInfo = ` - ${adjTile.angle.toFixed(1)}Â° ${arrow}`;
                        if (adjTile.diff !== null && adjTile.diff !== undefined) {
                            angleInfo += ` (Î”${adjTile.diff.toFixed(1)}Â°)`;
                        }
                        text += angleInfo;
                    }
                    
                    // ê°ë„ê°€ ë¹„ìŠ·í•˜ë©´ ë³„í‘œ ì¶”ê°€, ì•„ë‹ˆë©´ ê°™ì€ ê¸¸ì´ì˜ ì „ê° ê³µë°± ì¶”ê°€
                    if (adjTile.isPreferred) {
                        text = `â˜…â˜… ${text}`;
                    } else {
                        text = `ã€€ã€€ ${text}`;  // ì „ê° ê³µë°± 2ê°œì™€ ì¼ë°˜ ê³µë°± 1ê°œ
                    }
                    
                    // textareaì— ì¶”ê°€
                    textareaInfo += `  ${text}\n`;
                    
                    // select ì˜µì…˜ ìƒì„± (ë…¹ìƒ‰ í‘œì‹œ)
                    const displayText = `${index}. (${adjTile.r}, ${adjTile.c})${angleInfo}`;
                    const color = adjTile.isPreferred ? '#00ff00' : null;
                    tileSelect.appendChild(createTileOption(index, displayText, color));
                });
                
                // íƒ€ì¼ì´ ìˆëŠ” ê²½ìš° í•˜ë‹¨ì—ë„ ê°•ì¡° í‘œì‹œ
                if (adjacentCandidates.length >= 1) {
                    textareaInfo += `${'='.repeat(50)}\n`;
                }
            }
            
            // textarea ì—…ë°ì´íŠ¸
            // ì½˜ì†” ë¦¬ë‹¤ì´ë ‰ì…˜ê³¼ ë™ê¸°í™”í•˜ê¸° ìœ„í•´ outputTextì— ì§ì ‘ ì¶”ê°€
            if (typeof outputText !== 'undefined') {
                outputText += textareaInfo;
            }
            const outputArea = document.getElementById('output');
            if (outputArea) {
                outputArea.value = outputText || outputArea.value + textareaInfo;
                outputArea.scrollTop = outputArea.scrollHeight;
            }
            
            // selectë¥¼ ê¸°ë³¸ ì˜µì…˜ìœ¼ë¡œ ë¦¬ì…‹
            tileSelect.selectedIndex = 0;
            tileSelect.value = '';
            
            document.getElementById('currentTileInfo').textContent = `í˜„ì¬ íƒ€ì¼: (${tiles[cur].r}, ${tiles[cur].c})`;
        }
        
        // ì „ì—­ìœ¼ë¡œ ë…¸ì¶œ
        window.updateTileOptions = updateTileOptions;

        // ë²„íŠ¼ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
        function handleUserInput(value) {
            // console.log(`handleUserInput called with value: "${value}" (type: ${typeof value})`);
            
            // ë¹ˆ ê°’ ì²´í¬ - ê²½ê³ ë§Œ í‘œì‹œí•˜ê³  ê³„ì† ëŒ€ê¸°
            if (value === '' || value === null || value === undefined) {
                console.log('Empty or invalid selection. Please select an option.');
                alert('ì˜µì…˜ì„ ì„ íƒí•´ì£¼ì„¸ìš”.');
                return; // Promise ê³„ì† ëŒ€ê¸°
            }
            
            // stopì€ í•­ìƒ í—ˆìš©
            if (value === 'stop') {
                console.log(`Special command received: ${value}`);
                if (userInputResolver) {
                    userInputResolver(value);
                    userInputResolver = null;
                }
                return;
            }
            
            // ìˆ«ì ì„ íƒì˜ ê²½ìš° - ì˜µì…˜ ì¡´ì¬ ì—¬ë¶€ì™€ ê´€ê³„ì—†ì´ ì¼ë‹¨ ì „ë‹¬
            // JavaScript ì½”ë“œì—ì„œ ì²˜ë¦¬í•˜ë„ë¡
            // console.log(`Resolving with value: "${value}"`);
            if (userInputResolver) {
                userInputResolver(value);
                userInputResolver = null;
            } else {
                console.log('No userInputResolver available.');
            }
        }
        
        // ìë™ì„ íƒ í•¨ìˆ˜: ì„ íƒê°€ëŠ¥í•œ íƒ€ì¼ì´ 1ê°œì¼ ë•Œ ê³„ì† ìë™ ì„ íƒ
        function handleAutoSelect() {
            const options = tileSelect.options;
            // ì²« ë²ˆì§¸ ì˜µì…˜ì€ "-- ì„ íƒ --"ì´ë¯€ë¡œ ì‹¤ì œ íƒ€ì¼ ì˜µì…˜ ê°œìˆ˜ëŠ” options.length - 1
            const tileCount = options.length - 1;
            
            if (tileCount === 0) {
                console.log('ìë™ì„ íƒ: ì„ íƒ ê°€ëŠ¥í•œ íƒ€ì¼ì´ ì—†ìŠµë‹ˆë‹¤.');
                alert('ì„ íƒ ê°€ëŠ¥í•œ íƒ€ì¼ì´ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }
            
            if (tileCount === 1) {
                // ì„ íƒ ê°€ëŠ¥í•œ íƒ€ì¼ì´ 1ê°œì¸ ê²½ìš° ìë™ ì„ íƒ
                const value = options[1].value; // ì²« ë²ˆì§¸ íƒ€ì¼ ì˜µì…˜
                console.log(`ìë™ì„ íƒ: íƒ€ì¼ ${value}ë¥¼ ì„ íƒí•©ë‹ˆë‹¤.`);
                
                // ìë™ì„ íƒ ëª¨ë“œ í™œì„±í™”
                window.autoSelectMode = true;
                handleUserInput(value);
            } else {
                // 2ê°œ ì´ìƒì¸ ê²½ìš°
                console.log(`ìë™ì„ íƒ: ì„ íƒ ê°€ëŠ¥í•œ íƒ€ì¼ì´ ${tileCount}ê°œì…ë‹ˆë‹¤. ìˆ˜ë™ìœ¼ë¡œ ì„ íƒí•´ì£¼ì„¸ìš”.`);
                alert(`ì„ íƒ ê°€ëŠ¥í•œ íƒ€ì¼ì´ ${tileCount}ê°œì…ë‹ˆë‹¤. ìˆ˜ë™ìœ¼ë¡œ ì„ íƒí•´ì£¼ì„¸ìš”.`);
            }
        }
        
        selectTileButton.addEventListener('click', () => handleUserInput(tileSelect.value));
        
        // ìë™ì„ íƒ ë²„íŠ¼ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
        const autoSelectButton = document.getElementById('autoSelect');
        autoSelectButton.addEventListener('click', handleAutoSelect);
        
        stopSelectionButton.addEventListener('click', () => handleUserInput('stop'));

        // ì´ˆê¸°ì—ëŠ” ì…ë ¥ ì„¹ì…˜ ìˆ¨ê¹€
        showInputSection(false);
        
        // CTRL-Vë¡œ ì´ë¯¸ì§€ ë¶™ì—¬ë„£ê¸° ì²˜ë¦¬
        const inputCanvas = document.getElementById('inputCanvas');
        const inputCtx = inputCanvas.getContext('2d');
        const gridLoadStatus = document.getElementById('gridLoadStatus');
        let pastedImage = null;
        let startPos = { x: 0, y: 0 }; // ê¸°ë³¸ ì‹œì‘ ìœ„ì¹˜ (0,0)

        document.addEventListener('paste', (e) => {
            const items = Array.from(e.clipboardData.items);
            const imageItem = items.find(item => item.type.indexOf('image') !== -1);
            
            if (imageItem) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => {
                        loadImageOnCanvas(img, 'ì´ë¯¸ì§€ê°€ ìº”ë²„ìŠ¤ì— ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤. ì‹œì‘ ìœ„ì¹˜ë¥¼ í´ë¦­í•˜ê±°ë‚˜ "ì´ë¯¸ì§€ì—ì„œ ê·¸ë¦¬ë“œ ë¡œë“œ" ë²„íŠ¼ì„ í´ë¦­í•˜ì„¸ìš”.');
                        saveImageToLocalStorage();
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(imageItem.getAsFile());
            }
        });

        // ì´ë¯¸ì§€ ë¡œì»¬ ì €ì¥ ë° ë¡œë“œ
        function saveImageToLocalStorage() {
            try {
                localStorage.setItem('savedImage', inputCanvas.toDataURL('image/png'));
                console.log('ì´ë¯¸ì§€ê°€ localStorageì— ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.');
            } catch (e) {
                console.error('ì´ë¯¸ì§€ ì €ì¥ ì‹¤íŒ¨:', e);
            }
        }

        function loadImageOnCanvas(img, message) {
            inputCanvas.width = Math.min(img.width, 400);
            inputCanvas.height = Math.min(img.height, 400);
            inputCtx.clearRect(0, 0, inputCanvas.width, inputCanvas.height);
            inputCtx.drawImage(img, 0, 0, inputCanvas.width, inputCanvas.height);
            pastedImage = img;
            gridLoadStatus.textContent = message;
        }

        function loadImageFromLocalStorage() {
            try {
                const savedImageData = localStorage.getItem('savedImage');
                if (savedImageData) {
                    const img = new Image();
                    img.onload = () => {
                        loadImageOnCanvas(img, 'ì´ì „ì— ì €ì¥ëœ ì´ë¯¸ì§€ê°€ ìë™ìœ¼ë¡œ ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤.');
                        console.log('localStorageì—ì„œ ì´ë¯¸ì§€ë¥¼ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤.');
                    };
                    img.src = savedImageData;
                }
            } catch (e) {
                console.error('ì´ë¯¸ì§€ ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨:', e);
            }
        }

        // í˜ì´ì§€ ë¡œë“œ ì‹œ ì´ë¯¸ì§€ ë¶ˆëŸ¬ì˜¤ê¸°
        loadImageFromLocalStorage();

        // ìº”ë²„ìŠ¤ í´ë¦­ ì´ë²¤íŠ¸ë¡œ ì‹œì‘ ìœ„ì¹˜ ì§€ì •
        inputCanvas.addEventListener('click', (e) => {
            if (!pastedImage) return;
            
            const rect = inputCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            startPos = { x, y };
            gridLoadStatus.textContent = `ì‹œì‘ ìœ„ì¹˜: (${Math.floor(x)}, ${Math.floor(y)}). "ì´ë¯¸ì§€ì—ì„œ ê·¸ë¦¬ë“œ ë¡œë“œ" ë²„íŠ¼ì„ í´ë¦­í•˜ì„¸ìš”.`;
            
            // ì›ë³¸ ì´ë¯¸ì§€ë¥¼ ë‹¤ì‹œ ê·¸ë ¤ì„œ ì´ì „ ë¹¨ê°„ ì  ì œê±°
            inputCtx.clearRect(0, 0, inputCanvas.width, inputCanvas.height);
            inputCtx.drawImage(pastedImage, 0, 0, inputCanvas.width, inputCanvas.height);
            
            // ìƒˆë¡œìš´ ì‹œì‘ ìœ„ì¹˜ì— ë¹¨ê°„ ì  í‘œì‹œ
            inputCtx.beginPath();
            inputCtx.arc(x, y, 5, 0, 2 * Math.PI);
            inputCtx.fillStyle = 'red';
            inputCtx.fill();
        });

        // ì´ë¯¸ì§€ì—ì„œ ê·¸ë¦¬ë“œ ë¡œë“œ ë²„íŠ¼ ì´ë²¤íŠ¸
        document.getElementById('loadGridFromImage').addEventListener('click', () => {
            if (!pastedImage) {
                gridLoadStatus.textContent = 'ì´ë¯¸ì§€ê°€ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. CTRL-Vë¡œ ì´ë¯¸ì§€ë¥¼ ë¶™ì—¬ë„£ìœ¼ì„¸ìš”.';
                return;
            }
            
            // ê·¸ë¦¬ë“œë¥¼ ì½ê¸° ì „ì— ì›ë³¸ ì´ë¯¸ì§€ë¥¼ ë³µì› (ë¹¨ê°„ ì  ì œê±°)
            inputCtx.clearRect(0, 0, inputCanvas.width, inputCanvas.height);
            inputCtx.drawImage(pastedImage, 0, 0, inputCanvas.width, inputCanvas.height);
            
            const newGrid = loadGridFromCanvas(inputCanvas, inputCtx, startPos);
            if (newGrid?.length > 0 && newGrid[0]?.length > 0) {
                window.currentGrid = newGrid;
                gridLoadStatus.textContent = 'ê·¸ë¦¬ë“œê°€ ì„±ê³µì ìœ¼ë¡œ ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤.';
                if (typeof printGridOnly !== 'undefined') {
                    printGridOnly(newGrid, 'Initial Grid State');
                }
                document.getElementById('startTileCalculation').style.display = 'inline-block';
            } else {
                gridLoadStatus.textContent = 'ê·¸ë¦¬ë“œ ë¡œë“œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ì´ë¯¸ì§€ê°€ ì˜¬ë°”ë¥¸ì§€ í™•ì¸í•˜ì„¸ìš”.';
            }
        });

        // íƒ€ì¼ ê³„ì‚° ì‹œì‘ ë²„íŠ¼ ì´ë²¤íŠ¸
        document.getElementById('startTileCalculation').addEventListener('click', () => {
            if (!window.currentGrid) {
                gridLoadStatus.textContent = 'ê·¸ë¦¬ë“œê°€ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ë¨¼ì € ì´ë¯¸ì§€ë¥¼ ë¡œë“œí•˜ì„¸ìš”.';
                return;
            }
            
            gridLoadStatus.textContent = 'íƒ€ì¼ ë°°ì¹˜ë¥¼ ì°¾ê³  ìˆìŠµë‹ˆë‹¤.';
            document.getElementById('calculationStatus').style.display = 'block';
            
            const tileSize = parseInt(document.getElementById('tileSizeSelect').value, 10);
            const startPosition = document.getElementById('startPositionSelect').value;
            const startAngle = parseFloat(document.getElementById('startAngleSelect').value);
            
            const startRuleMap = { topLeft: 'topleft', topRight: 'topright', custom: 'custom' };
            const startRule = startRuleMap[startPosition] || 'topleft';
            
            let customStartTile = null;
            if (startRule === 'custom') {
                const r = parseInt(document.getElementById('startTileR').value, 10);
                const c = parseInt(document.getElementById('startTileC').value, 10);
                customStartTile = { r, c };
                console.log(`Custom start tile: (${r}, ${c})`);
            }
            console.log(`Start angle: ${startAngle}Â°`);
            
            const result = getAllPossiblePlacements(window.currentGrid, tileSize, {
                startRule,
                customStartTile,
                startAngle
            });
            
            document.getElementById('calculationStatus').style.display = 'none';
            
            if (!result.placements || result.placements.length === 0) {
                console.log('No valid tile placements found.');
                return;
            }
            
            window.savedPlacements = result.placements;
            window.savedConfig = { tileSize, startRule, customStartTile, startAngle };
            
            console.log(`Found ${result.placements.length} possible tile placements.`);
            
            // ì´ˆê¸° íƒ€ì¼ í‘œì‹œ
            printPlacementAscii(window.currentGrid, result.initialTiles, tileSize, '-- Starting Position --');
            if (typeof window.updateTilePath === 'function') {
                window.updateTilePath(result.initialTiles);
            }
            
            // ì‚¬ìš©ì ì„ íƒ ëª¨ë“œ ì‹œì‘
            const nextRule = makeNextByWeightedWithMaxDist({ wDist: 1.0, wTurn: 2.5, maxDist: 2.5 });
            const orderingResult = orderTilesWithNextRule(
                result.initialTiles,
                tileSize,
                nextRule,
                startRule,
                120,
                window.currentGrid,
                customStartTile,
                startAngle
            );
            
            if (orderingResult?.state) {
                console.log("Starting manual tile selection...");
                resumeTileOrdering(orderingResult.state, 120, window.savedPlacements, window.currentGrid)
                    .then(result => {
                        if (result?.orderedTiles) {
                            console.log("Tile selection completed. Final tiles:", result.orderedTiles.map(t => `(${t.r},${t.c})`).join(" "));
                            
                            // TileResultManagerì— ê²°ê³¼ ì €ì¥
                            TileResultManager.save(result);
                        }
                    })
                    .catch(error => console.error("Error during tile selection:", error));
            }
        });
        
        // ì²« íƒ€ì¼ ìœ„ì¹˜ ì„ íƒ ì‹œ Custom ì˜µì…˜ì— ë”°ë¼ ì…ë ¥ í•„ë“œ í‘œì‹œ/ìˆ¨ê¹€
        document.getElementById('startPositionSelect').addEventListener('change', () => {
            const startPosition = document.getElementById('startPositionSelect').value;
            document.getElementById('customStartTile').style.display = startPosition === 'custom' ? 'inline-block' : 'none';
        });

        // ìº”ë²„ìŠ¤ì—ì„œ ì„ íƒëœ í¬ê¸°ì˜ ê·¸ë¦¬ë“œë¥¼ ë¡œë“œí•˜ëŠ” í•¨ìˆ˜
        function loadGridFromCanvas(canvas, ctx, startPos = { x: 0, y: 0 }) {
            const gridSize = parseInt(document.getElementById('gridSizeSelect').value, 10);
            const imgWidth = pastedImage?.width || canvas.width;
            const imgHeight = pastedImage?.height || canvas.height;
            const scaleX = imgWidth / canvas.width;
            const scaleY = imgHeight / canvas.height;
            // í´ë¦­í•œ ìœ„ì¹˜ë¥¼ ì¤‘ì‹¬ìœ¼ë¡œ í•˜ê¸° ìœ„í•´ gridSize/2ë§Œí¼ ì™¼ìª½ ìœ„ë¡œ ì´ë™
            const halfGrid = gridSize / 2;
            const imgStartX = (startPos.x - halfGrid) * scaleX;
            const imgStartY = (startPos.y - halfGrid) * scaleY;
            
            const grid = [];
            for (let r = 0; r < gridSize; r++) {
                const row = [];
                for (let c = 0; c < gridSize; c++) {
                    const canvasX = (imgStartX + c) / scaleX;
                    const canvasY = (imgStartY + r) / scaleY;
                    
                    if (canvasX >= 0 && canvasX < canvas.width && canvasY >= 0 && canvasY < canvas.height) {
                        const pixelData = ctx.getImageData(Math.floor(canvasX), Math.floor(canvasY), 1, 1).data;
                        const isBlack = pixelData[0] < 50 && pixelData[1] < 50 && pixelData[2] < 50;
                        row.push(isBlack ? 1 : 0);
                    } else {
                        row.push(0);
                    }
                }
                grid.push(row);
            }
            return grid;
        }

        // íƒ€ì¼ ê·¸ë£¹ í‘œì‹œ í•¨ìˆ˜
        let currentTileGroups = null;
        let currentTileSize = 2;

        window.displayTileGroups = function(groupsForDisplay) {
            currentTileGroups = groupsForDisplay;
            const groupingSection = document.getElementById('groupingSection');
            const groupsDisplay = document.getElementById('groupsDisplay');
            
            if (!groupsForDisplay || groupsForDisplay.length === 0) {
                groupingSection.style.display = 'none';
                return;
            }
            
            groupingSection.style.display = 'block';
            
            let html = '<div style="color: #ffffff;">';
            groupsForDisplay.forEach(group => {
                html += `
                    <div style="margin-bottom: 20px; padding: 15px; background-color: #3a3a3a; border-left: 4px solid #00aaff; border-radius: 3px;">
                        <div style="font-size: 16px; font-weight: bold; margin-bottom: 10px; color: #00aaff;">
                            ê·¸ë£¹ ${group.groupNumber} (${group.tileCount}ê°œ íƒ€ì¼)
                        </div>
                        <div style="margin-bottom: 5px;">
                            <span style="color: #aaaaaa;">í‰ê·  ê°ë„:</span> 
                            <span style="color: #ffffff; font-weight: bold;">
                                ${group.avgAngle !== null ? group.avgAngle.toFixed(1) + 'Â° ' + group.arrow : 'N/A'}
                            </span>
                        </div>
                        <div style="margin-bottom: 5px;">
                            <span style="color: #aaaaaa;">íƒ€ì¼ ê²½ë¡œ:</span> 
                            <span style="color: #ffff00; font-family: monospace; font-size: 14px;">
                                ${group.tileLabels}
                            </span>
                        </div>
                        <div>
                            <span style="color: #aaaaaa;">ì¢Œí‘œ:</span> 
                            <span style="color: #cccccc; font-size: 12px;">
                                ${group.tiles}
                            </span>
                        </div>
                    </div>
                `;
            });
            html += '</div>';
            
            groupsDisplay.innerHTML = html;
        };

        // í´ë¦½ë³´ë“œì— ë³µì‚¬ ë²„íŠ¼ ì´ë²¤íŠ¸
        document.getElementById('copyToClipboard').addEventListener('click', () => {
            const result = TileResultManager.get();
            
            if (!result || !result.orderedTiles || result.orderedTiles.length === 0) {
                alert('ì €ì¥ëœ íƒ€ì¼ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.\në¨¼ì € íƒ€ì¼ì„ ì„ íƒí•˜ê³  "ì¤‘ì§€" ë²„íŠ¼ì„ ëˆŒëŸ¬ì£¼ì„¸ìš”.');
                return;
            }
            
            // JSON í˜•ì‹ìœ¼ë¡œ ë°ì´í„° ì¤€ë¹„
            const exportData = {
                tiles: result.orderedTiles,
                groups: result.groups.map(g => ({
                    tiles: g.tiles,
                    avgAngle: g.avgAngle,
                    angles: g.angles,
                    tileCount: g.tiles.length
                })),
                metadata: {
                    totalTiles: result.orderedTiles.length,
                    totalGroups: result.groups.length,
                    timestamp: new Date().toISOString(),
                    source: 'Block Move Solver'
                }
            };
            
            // í´ë¦½ë³´ë“œì— ë³µì‚¬
            navigator.clipboard.writeText(JSON.stringify(exportData, null, 2))
                .then(() => {
                    // ì„±ê³µ ë©”ì‹œì§€
                    const copyButton = document.getElementById('copyToClipboard');
                    const originalText = copyButton.innerHTML;
                    copyButton.innerHTML = 'âœ“ ë³µì‚¬ ì™„ë£Œ!';
                    copyButton.style.backgroundColor = '#00aa00';
                    
                    console.log('âœ“ ë°ì´í„°ê°€ í´ë¦½ë³´ë“œì— ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤.');
                    console.log(`- ì´ íƒ€ì¼: ${exportData.metadata.totalTiles}ê°œ`);
                    console.log(`- ì´ ê·¸ë£¹: ${exportData.metadata.totalGroups}ê°œ`);
                    
                    // 3ì´ˆ í›„ ì›ë˜ëŒ€ë¡œ
                    setTimeout(() => {
                        copyButton.innerHTML = originalText;
                        copyButton.style.backgroundColor = '#0066cc';
                    }, 3000);
                })
                .catch(err => {
                    console.error('í´ë¦½ë³´ë“œ ë³µì‚¬ ì‹¤íŒ¨:', err);
                    alert('í´ë¦½ë³´ë“œ ë³µì‚¬ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.\n' + err.message);
                });
        });

        // ë‹¤ì‹œ ê·¸ë£¹í•‘ ë²„íŠ¼ ì´ë²¤íŠ¸
        document.getElementById('regroupButton').addEventListener('click', () => {
            const angleThreshold = parseFloat(document.getElementById('angleThresholdInput').value) || 45;
            window.groupingAngleThreshold = angleThreshold;
            
            // í˜„ì¬ ì„ íƒëœ íƒ€ì¼ ê²½ë¡œë¥¼ ê°€ì ¸ì˜´
            if (currentTilePath && currentTilePath.length > 0 && typeof window.groupTilesByAngle === 'function') {
                console.log(`ë‹¤ì‹œ ê·¸ë£¹í•‘ ì¤‘... (ê°ë„ ì„ê³„ê°’: ${angleThreshold}Â°)`);
                
                const groups = window.groupTilesByAngle(currentTilePath, currentTileSize, angleThreshold);
                
                if (typeof window.printTileGroups === 'function') {
                    window.printTileGroups(groups, currentTileSize);
                }
                
                if (typeof window.formatGroupsForDisplay === 'function') {
                    const groupsForDisplay = window.formatGroupsForDisplay(groups);
                    window.displayTileGroups(groupsForDisplay);
                }
            } else {
                console.log('ë‹¤ì‹œ ê·¸ë£¹í•‘í•  íƒ€ì¼ì´ ì—†ìŠµë‹ˆë‹¤. ë¨¼ì € íƒ€ì¼ì„ ì„ íƒí•´ì£¼ì„¸ìš”.');
            }
        });

        // íƒ€ì¼ ê²½ë¡œ ì—…ë°ì´íŠ¸ ì‹œ íƒ€ì¼ í¬ê¸°ë„ ì €ì¥
        const originalUpdateTilePath = window.updateTilePath;
        window.updateTilePath = function(tiles) {
            if (originalUpdateTilePath) {
                originalUpdateTilePath(tiles);
            }
            // í˜„ì¬ íƒ€ì¼ í¬ê¸° ì €ì¥
            const tileSizeSelect = document.getElementById('tileSizeSelect');
            if (tileSizeSelect) {
                currentTileSize = parseInt(tileSizeSelect.value, 10) || 2;
            }
        };
    </script>
    <script src="blockMove.js"></script>
</body>
</html>
