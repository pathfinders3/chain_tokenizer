<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Block Move Solver Output</title>
    <link rel="icon" type="image/png" href="blockMove.png">
    <style>
        body {
            font-family: monospace;
            margin: 20px;
            background-color: #1e1e1e;
            color: #ffffff;
        }
        h1 {
            color: #ffffff;
        }
        textarea {
            width: 100%;
            height: 600px;
            font-family: 'Courier New', Courier, monospace;
            font-size: 14px;
            line-height: 1.2;
            background-color: #2d2d2d;
            color: #ffffff;
            border: 1px solid #444;
            padding: 10px;
            resize: vertical;
            white-space: pre;
        }
    </style>
</head>
<body>
    <h1>Block Move Solver Output</h1>
    <div id="inputCanvasContainer" style="margin-bottom: 20px;">
        <p>이미지를 붙여넣으려면 아래 캔버스에 CTRL-V를 사용하세요. 시작 위치를 지정하려면 캔버스를 클릭하세요:</p>
        <canvas id="inputCanvas" width="400" height="400" style="border: 1px solid #444; cursor: crosshair;"></canvas>
        <div style="margin-top: 10px;">
            <label for="gridSizeSelect">그리드 크기 선택:</label>
            <select id="gridSizeSelect">
                <option value="8">8x8</option>
                <option value="16">16x16</option>
            </select>
            <label for="iterationLimitSelect">반복 횟수 제한:</label>
            <select id="iterationLimitSelect">
                <option value="100000">100,000</option>
                <option value="50000">50,000</option>
                <option value="20000">20,000</option>
                <option value="10000">10,000</option>
            </select>
            <label for="depthLimitSelect">깊이 제한:</label>
            <select id="depthLimitSelect">
                <option value="15">15</option>
                <option value="20">20</option>
                <option value="25">25</option>
                <option value="30">30</option>
                <option value="35">35</option>
                <option value="40">40</option>
                <option value="50" selected>50</option>
                <option value="60">60</option>
                <option value="70">70</option>
            </select>
            <p style="font-size: 12px; color: #aaaaaa;">참고: 큰 그리드(16x16 등)에서는 깊이 제한 50 이상을 권장합니다.</p>
            <button id="loadGridFromImage">이미지에서 그리드 로드</button>
            <button id="startTileCalculation" style="display: none;">타일 계산 시작</button>
            <label for="startPositionSelect">첫 타일 위치:</label>
            <select id="startPositionSelect">
                <option value="topLeft">Top-Left</option>
                <option value="topRight">Top-Right</option>
                <option value="custom">Custom</option>
            </select>
            <span id="customStartTile" style="display: none;">
                <label for="startTileR">Row:</label>
                <input type="number" id="startTileR" min="0" value="0" style="width: 60px;">
                <label for="startTileC">Column:</label>
                <input type="number" id="startTileC" min="0" value="1" style="width: 60px;">
            </span>
            <label for="startAngleSelect">시작 각도(방향):</label>
            <select id="startAngleSelect">
                <option value="0">→ (0°, 오른쪽)</option>
                <option value="45">↗ (45°, 오른쪽 위)</option>
                <option value="90">↑ (90°, 위)</option>
                <option value="135">↖ (135°, 왼쪽 위)</option>
                <option value="180">← (180°, 왼쪽)</option>
                <option value="225">↙ (225°, 왼쪽 아래)</option>
                <option value="270">↓ (270°, 아래)</option>
                <option value="315">↘ (315°, 오른쪽 아래)</option>
            </select>
            <label for="tileSizeSelect">타일 크기:</label>
            <select id="tileSizeSelect">
                <option value="2">2x2</option>
                <option value="3">3x3</option>
            </select>
        </div>
        <p id="gridLoadStatus"></p>
        <p id="calculationStatus" style="font-weight: bold; color: #ffff00; display: none;">계산 진행 중입니다. 잠시만 기다려 주세요...</p>
    </div>
    <textarea id="output" readonly>
        계산 중입니다. 잠시만 기다려 주세요...
    </textarea>
    <div id="inputSection" style="margin-top: 20px;">
        <label for="tileSelect">다음 타일을 선택하세요:</label>
        <span id="currentTileInfo" style="margin-left: 10px; font-weight: bold; color: #ffff00;">현재 타일: 없음</span>
        <br>
        <select id="tileSelect">
            <option value="">-- 선택 --</option>
        </select>
        <button id="selectTile">선택</button>
        <button id="autoSelect">자동 선택</button>
        <button id="stopSelection">중지</button>
    </div>
    <div id="canvasContainer" style="margin-top: 20px; display: none;">
        <canvas id="resultCanvas" style="border: 1px solid #444;"></canvas>
        <p>결과 이미지가 생성되었습니다. 클립보드에 복사되었습니다.</p>
    </div>

    <script>
        // 콘솔 출력을 textarea에 리다이렉트
        const outputElement = document.getElementById('output');
        let outputText = '';

        // 콘솔 메서드 오버라이드
        const originalConsoleLog = console.log;
        console.log = function(...args) {
            outputText += args.join(' ') + '\n';
            outputElement.value = outputText;
            outputElement.scrollTop = outputElement.scrollHeight;
            originalConsoleLog.apply(console, args);
        };

        const originalConsoleError = console.error;
        console.error = function(...args) {
            outputText += 'ERROR: ' + args.join(' ') + '\n';
            outputElement.value = outputText;
            outputElement.scrollTop = outputElement.scrollHeight;
            originalConsoleError.apply(console, args);
        };

        const originalConsoleWarn = console.warn;
        console.warn = function(...args) {
            outputText += 'WARN: ' + args.join(' ') + '\n';
            outputElement.value = outputText;
            outputElement.scrollTop = outputElement.scrollHeight;
            originalConsoleWarn.apply(console, args);
        };

        // 사용자 입력 처리를 위한 전역 변수
        let userInputResolver = null;
        const tileSelect = document.getElementById('tileSelect');
        const selectTileButton = document.getElementById('selectTile');
        const autoSelectButton = document.getElementById('autoSelect');
        const stopSelectionButton = document.getElementById('stopSelection');
        const inputSection = document.getElementById('inputSection');

        // 입력 섹션 표시/숨김
        function showInputSection(show) {
            inputSection.style.display = show ? 'block' : 'none';
        }

        // 타일 선택 옵션 업데이트
        function updateTileOptions(candidates, tiles, cur, centers, k, prevAngle, adjacentCandidates = []) {
            tileSelect.innerHTML = '<option value="">-- 선택 --</option>';
            
            // DFS 타일 추가
            candidates.forEach((cand, index) => {
                const tile = tiles[cand.i];
                const dist = tileDist(centers[cur], centers[cand.i], k);
                const ang = angleDegCart(centers[cur], centers[cand.i]);
                const turn = prevAngle == null ? 0 : angleDiff(prevAngle, ang);
                const option = document.createElement('option');
                option.value = index;
                option.textContent = `${index + 1}. Tile at (${tile.r}, ${tile.c}) - Distance: ${dist.toFixed(2)}, Angle: ${ang.toFixed(1)}°, Turn: ${turn.toFixed(1)}°`;
                tileSelect.appendChild(option);
            });
            
            // 인접 타일 추가
            if (adjacentCandidates && adjacentCandidates.length > 0) {
                adjacentCandidates.forEach((adjTile, index) => {
                    const adjIndex = candidates.length + index;
                    const option = document.createElement('option');
                    option.value = adjIndex;
                    option.textContent = `${adjIndex + 1}. [Adj.] Tile at (${adjTile.r}, ${adjTile.c})`;
                    option.style.color = '#00ff00'; // 녹색으로 표시
                    tileSelect.appendChild(option);
                });
            }
            
            // 현재 타일 정보 업데이트
            document.getElementById('currentTileInfo').textContent = `현재 타일: (${tiles[cur].r}, ${tiles[cur].c})`;
        }

        // 버튼 이벤트 리스너
        selectTileButton.addEventListener('click', () => {
            if (userInputResolver) {
                const selectedValue = tileSelect.value;
                userInputResolver(selectedValue);
                userInputResolver = null;
            }
        });

        autoSelectButton.addEventListener('click', () => {
            if (userInputResolver) {
                userInputResolver('auto');
                userInputResolver = null;
            }
        });

        stopSelectionButton.addEventListener('click', () => {
            if (userInputResolver) {
                userInputResolver('stop');
                userInputResolver = null;
            }
        });

        // 초기에는 입력 섹션 숨김
        showInputSection(false);
        
        // CTRL-V로 이미지 붙여넣기 처리
        const inputCanvas = document.getElementById('inputCanvas');
        const inputCtx = inputCanvas.getContext('2d');
        const gridLoadStatus = document.getElementById('gridLoadStatus');
        let pastedImage = null;
        let startPos = { x: 0, y: 0 }; // 기본 시작 위치 (0,0)

        document.addEventListener('paste', (e) => {
            const items = e.clipboardData.items;
            for (let i = 0; i < items.length; i++) {
                if (items[i].type.indexOf('image') !== -1) {
                    const blob = items[i].getAsFile();
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        const img = new Image();
                        img.onload = () => {
                            inputCanvas.width = Math.min(img.width, 400);
                            inputCanvas.height = Math.min(img.height, 400);
                            inputCtx.clearRect(0, 0, inputCanvas.width, inputCanvas.height);
                            inputCtx.drawImage(img, 0, 0, inputCanvas.width, inputCanvas.height);
                            pastedImage = img;
                            gridLoadStatus.textContent = '이미지가 캔버스에 로드되었습니다. 시작 위치를 클릭하거나 "이미지에서 그리드 로드" 버튼을 클릭하세요.';
                            
                            // 이미지를 localStorage에 저장
                            saveImageToLocalStorage();
                        };
                        img.src = event.target.result;
                    };
                    reader.readAsDataURL(blob);
                    break;
                }
            }
        });

        // 이미지를 localStorage에 저장하는 함수
        function saveImageToLocalStorage() {
            try {
                const dataURL = inputCanvas.toDataURL('image/png');
                localStorage.setItem('savedImage', dataURL);
                console.log('이미지가 localStorage에 저장되었습니다.');
            } catch (e) {
                console.error('이미지 저장 실패:', e);
            }
        }

        // 페이지 로드 시 localStorage에서 이미지 불러오기
        function loadImageFromLocalStorage() {
            try {
                const savedImageData = localStorage.getItem('savedImage');
                if (savedImageData) {
                    const img = new Image();
                    img.onload = () => {
                        inputCanvas.width = Math.min(img.width, 400);
                        inputCanvas.height = Math.min(img.height, 400);
                        inputCtx.clearRect(0, 0, inputCanvas.width, inputCanvas.height);
                        inputCtx.drawImage(img, 0, 0, inputCanvas.width, inputCanvas.height);
                        pastedImage = img;
                        gridLoadStatus.textContent = '이전에 저장된 이미지가 자동으로 로드되었습니다.';
                        console.log('localStorage에서 이미지를 불러왔습니다.');
                    };
                    img.src = savedImageData;
                }
            } catch (e) {
                console.error('이미지 불러오기 실패:', e);
            }
        }

        // 페이지 로드 시 이미지 불러오기
        loadImageFromLocalStorage();

        // 캔버스 클릭 이벤트로 시작 위치 지정
        inputCanvas.addEventListener('click', (e) => {
            const rect = inputCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            startPos = { x, y };
            gridLoadStatus.textContent = `시작 위치가 (${Math.floor(x)}, ${Math.floor(y)})로 설정되었습니다. "이미지에서 그리드 로드" 버튼을 클릭하세요.`;
            
            // 클릭 위치에 표시를 위해 캔버스에 점 그리기
            inputCtx.beginPath();
            inputCtx.arc(x, y, 5, 0, 2 * Math.PI);
            inputCtx.fillStyle = 'red';
            inputCtx.fill();
        });

        // 이미지에서 그리드 로드 버튼 이벤트
        document.getElementById('loadGridFromImage').addEventListener('click', () => {
            if (pastedImage) {
                const newGrid = loadGridFromCanvas(inputCanvas, inputCtx, startPos);
                if (newGrid && newGrid.length > 0 && newGrid[0].length > 0) {
                    window.currentGrid = newGrid; // 전역 변수로 저장
                    gridLoadStatus.textContent = '그리드가 성공적으로 로드되었습니다.';
                    console.log('New grid loaded from image:', newGrid);
                    // 초기 그리드 상태를 보여줌 (printGridOnly는 blockMove.js에 정의됨)
                    if (typeof printGridOnly !== 'undefined') {
                        printGridOnly(newGrid, 'Initial Grid State');
                    }
                    // '타일 계산 시작' 버튼 표시
                    document.getElementById('startTileCalculation').style.display = 'inline-block';
                } else {
                    gridLoadStatus.textContent = '그리드 로드에 실패했습니다. 이미지가 올바른지 확인하세요.';
                }
            } else {
                gridLoadStatus.textContent = '이미지가 로드되지 않았습니다. CTRL-V로 이미지를 붙여넣으세요.';
            }
        });

        // 타일 계산 시작 버튼 이벤트
        document.getElementById('startTileCalculation').addEventListener('click', () => {
            if (window.currentGrid) {
                gridLoadStatus.textContent = '타일 계산을 시작합니다.';
                document.getElementById('calculationStatus').style.display = 'block';
                const iterationLimit = parseInt(document.getElementById('iterationLimitSelect').value, 10);
                const depthLimit = parseInt(document.getElementById('depthLimitSelect').value, 10);
                const startPosition = document.getElementById('startPositionSelect').value;
                const tileSize = parseInt(document.getElementById('tileSizeSelect').value, 10);
                const startAngle = parseFloat(document.getElementById('startAngleSelect').value);
                let startRule = startPosition === 'topLeft' ? 'topleft' : (startPosition === 'topRight' ? 'topright' : 'custom');
                let customStartTile = null;
                if (startRule === 'custom') {
                    const r = parseInt(document.getElementById('startTileR').value, 10);
                    const c = parseInt(document.getElementById('startTileC').value, 10);
                    customStartTile = { r, c };
                    console.log(`Custom start tile specified: (${r}, ${c})`);
                }
                console.log(`Start angle specified: ${startAngle}°`);
                const solutions = printBestTilePlacements(window.currentGrid, tileSize, 1, {
                    showVisual: true,
                    showDirections: true,
                    order: "weighted",
                    weighted: { wDist: 1.0, wTurn: 2.5, maxDist: 2.5 },
                    maxAngleDiff: 60,
                    iterationLimit: iterationLimit,
                    depthLimit: depthLimit,
                    startRule: startRule,
                    customStartTile: customStartTile,
                    startAngle: startAngle
                });
                document.getElementById('calculationStatus').style.display = 'none';
                
                // placements와 전체 설정을 저장
                window.savedPlacements = solutions.placements;
                window.savedConfig = {
                    tileSize,
                    iterationLimit,
                    depthLimit,
                    startRule,
                    customStartTile,
                    startAngle
                };
                window.accumulatedTiles = []; // 누적 타일 초기화
                
                if (solutions && solutions[0]?.orderingState) {
                    console.log("Resuming tile ordering for the first solution...");
                    resumeTileOrdering(solutions[0].orderingState, 120, window.savedPlacements, window.currentGrid).then(resumedResult => {
                        if (resumedResult && resumedResult.rerunning) {
                            console.log("DFS re-run initiated. Waiting for new results...");
                        } else if (resumedResult && resumedResult.orderedTiles) {
                            console.log("Resumed ordered tiles:", resumedResult.orderedTiles.map(t => `(${t.r},${t.c})`).join(" "));
                        } else {
                            console.warn("Resume completed with no result:", resumedResult);
                        }
                    }).catch(error => {
                        console.error("Error while resuming tile ordering:", error);
                    });
                }
            } else {
                gridLoadStatus.textContent = '그리드가 로드되지 않았습니다. 먼저 이미지를 로드하세요.';
            }
        });
        
        // DFS 재실행 함수 (인접 타일 선택 시)
        window.rerunDFSWithNewTile = function(existingTiles, newTile) {
            // 누적 타일 업데이트 - existingTiles에 이미 모든 타일(기존 + 새 타일)이 포함되어 있음
            window.accumulatedTiles = existingTiles.slice(); // 전체 타일 리스트로 교체
            
            console.log(`Re-running DFS with accumulated tiles: ${window.accumulatedTiles.map(t => `(${t.r},${t.c})`).join(", ")}`);
            console.log(`Total accumulated tiles: ${window.accumulatedTiles.length}`);
            
            const config = window.savedConfig;
            
            // 원래 설정 유지하면서 DFS 재실행 (누적된 모든 타일 고정)
            const solutions = printBestTilePlacements(window.currentGrid, config.tileSize, 1, {
                showVisual: true,
                showDirections: true,
                order: "weighted",
                weighted: { wDist: 1.0, wTurn: 2.5, maxDist: 2.5 },
                maxAngleDiff: 120,
                iterationLimit: config.iterationLimit,
                depthLimit: config.depthLimit,
                startRule: config.startRule,           // 원래 startRule 유지
                customStartTile: config.customStartTile, // 원래 customStartTile 유지
                startAngle: config.startAngle,
                fixedTiles: window.accumulatedTiles // 누적된 모든 타일 고정
            });
            
            if (solutions && solutions.length > 0 && solutions[0]?.orderingState) {
                console.log("Resuming tile ordering after DFS re-run...");
                console.log(`New solution has ${solutions[0].tiles.length} tiles (including ${window.accumulatedTiles.length} fixed tiles)`);
                resumeTileOrdering(solutions[0].orderingState, 120, window.savedPlacements, window.currentGrid).then(resumedResult => {
                    if (resumedResult && resumedResult.orderedTiles) {
                        console.log("Resumed ordered tiles:", resumedResult.orderedTiles.map(t => `(${t.r},${t.c})`).join(" "));
                    } else {
                        console.error("Resume result is invalid:", resumedResult);
                    }
                }).catch(error => {
                    console.error("Error while resuming tile ordering:", error);
                });
            } else {
                console.error("No valid solutions found after DFS re-run. Solutions:", solutions);
                console.log("DFS could not find additional tiles with the given constraints. Try adjusting depth/iteration limits.");
            }
        };

        // 첫 타일 위치 선택 시 Custom 옵션에 따라 입력 필드 표시/숨김
        document.getElementById('startPositionSelect').addEventListener('change', () => {
            const startPosition = document.getElementById('startPositionSelect').value;
            document.getElementById('customStartTile').style.display = startPosition === 'custom' ? 'inline-block' : 'none';
        });

        // 캔버스에서 선택된 크기의 그리드를 로드하는 함수
        function loadGridFromCanvas(canvas, ctx, startPos = { x: 0, y: 0 }) {
            // 사용자가 선택한 그리드 크기 가져오기
            const gridSize = parseInt(document.getElementById('gridSizeSelect').value, 10);
            // 원본 이미지의 크기
            const imgWidth = pastedImage ? pastedImage.width : canvas.width;
            const imgHeight = pastedImage ? pastedImage.height : canvas.height;
            // 캔버스 좌표를 이미지 좌표로 변환
            const imgStartX = startPos.x * (imgWidth / canvas.width);
            const imgStartY = startPos.y * (imgHeight / canvas.height);
            const grid = [];
            for (let r = 0; r < gridSize; r++) {
                const row = [];
                for (let c = 0; c < gridSize; c++) {
                    // 이미지의 시작 위치 + (c, r) 위치를 캔버스 좌표로 변환
                    const imgX = imgStartX + c;
                    const imgY = imgStartY + r;
                    const canvasX = imgX * (canvas.width / imgWidth);
                    const canvasY = imgY * (canvas.height / imgHeight);
                    if (canvasX < canvas.width && canvasY < canvas.height && canvasX >= 0 && canvasY >= 0) {
                        const pixelData = ctx.getImageData(Math.floor(canvasX), Math.floor(canvasY), 1, 1).data;
                        // 검은색 근사치 확인 (RGB 기준으로 임의 설정, 예: R<50, G<50, B<50)
                        const isBlack = pixelData[0] < 50 && pixelData[1] < 50 && pixelData[2] < 50;
                        row.push(isBlack ? 1 : 0);
                    } else {
                        row.push(0); // 캔버스 범위를 벗어나면 0으로 설정
                    }
                }
                grid.push(row);
            }
            return grid;
        }
    </script>
    <script src="blockMove.js"></script>
</body>
</html>
