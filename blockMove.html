<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Block Move Solver Output</title>
    <link rel="icon" type="image/png" href="blockMove.png">
    <style>
        body {
            font-family: monospace;
            margin: 20px;
            background-color: #1e1e1e;
            color: #ffffff;
        }
        h1 {
            color: #ffffff;
        }
        textarea {
            width: 100%;
            height: 600px;
            font-family: 'Courier New', Courier, monospace;
            font-size: 14px;
            line-height: 1.2;
            background-color: #2d2d2d;
            color: #ffffff;
            border: 1px solid #444;
            padding: 10px;
            resize: vertical;
            white-space: pre;
        }
        select {
            background-color: #2d2d2d;
            color: #ffffff;
            border: 1px solid #444;
            padding: 5px;
            font-family: monospace;
            font-size: 14px;
        }
        option {
            background-color: #2d2d2d;
            color: #ffffff;
        }
    </style>
</head>
<body>
    <h1>Block Move Solver Output</h1>
    <div id="inputCanvasContainer" style="margin-bottom: 20px;">
        <p>이미지를 붙여넣으려면 아래 캔버스에 CTRL-V를 사용하세요. 시작 위치를 지정하려면 캔버스를 클릭하세요:</p>
        <canvas id="inputCanvas" width="400" height="400" style="border: 1px solid #444; cursor: crosshair;"></canvas>
        <div style="margin-top: 10px;">
            <label for="gridSizeSelect">그리드 크기 선택:</label>
            <select id="gridSizeSelect">
                <option value="8">8x8</option>
                <option value="16">16x16</option>
            </select>
            <button id="loadGridFromImage">이미지에서 그리드 로드</button>
            <button id="startTileCalculation" style="display: none;">타일 계산 시작</button>
            <label for="startPositionSelect">첫 타일 위치:</label>
            <select id="startPositionSelect">
                <option value="topLeft">Top-Left</option>
                <option value="topRight">Top-Right</option>
                <option value="custom">Custom</option>
            </select>
            <span id="customStartTile" style="display: none;">
                <label for="startTileR">Row:</label>
                <input type="number" id="startTileR" min="0" value="0" style="width: 60px;">
                <label for="startTileC">Column:</label>
                <input type="number" id="startTileC" min="0" value="1" style="width: 60px;">
            </span>
            <label for="startAngleSelect">시작 각도(방향):</label>
            <select id="startAngleSelect">
                <option value="0">→ (0°, 오른쪽)</option>
                <option value="45">↗ (45°, 오른쪽 위)</option>
                <option value="90">↑ (90°, 위)</option>
                <option value="135">↖ (135°, 왼쪽 위)</option>
                <option value="180">← (180°, 왼쪽)</option>
                <option value="225">↙ (225°, 왼쪽 아래)</option>
                <option value="270">↓ (270°, 아래)</option>
                <option value="315">↘ (315°, 오른쪽 아래)</option>
            </select>
            <label for="tileSizeSelect">타일 크기:</label>
            <select id="tileSizeSelect">
                <option value="2">2x2</option>
                <option value="3">3x3</option>
            </select>
        </div>
        <p id="gridLoadStatus"></p>
        <p id="calculationStatus" style="font-weight: bold; color: #ffff00; display: none;">계산 진행 중입니다. 잠시만 기다려 주세요...</p>
    </div>
    <textarea id="output" readonly>
        계산 중입니다. 잠시만 기다려 주세요...
    </textarea>
    <div id="inputSection" style="margin-top: 20px;">
        <label for="tileSelect">다음 타일을 선택하세요:</label>
        <span id="currentTileInfo" style="margin-left: 10px; font-weight: bold; color: #ffff00;">현재 타일: 없음</span>
        <br>
        <div id="tilePath" style="margin: 10px 0; padding: 10px; background-color: #2d2d2d; border: 1px solid #444; min-height: 30px;">
            <div style="font-size: 12px; color: #aaaaaa; margin-bottom: 5px;">연결된 타일 경로 (클릭하여 해당 타일부터 삭제):</div>
            <div id="tilePathItems" style="display: flex; flex-wrap: wrap; gap: 5px;"></div>
        </div>
        <select id="tileSelect">
            <option value="">-- 선택 --</option>
        </select>
        <button id="selectTile">선택</button>
        <button id="stopSelection">중지</button>
    </div>
    <div id="canvasContainer" style="margin-top: 20px; display: none;">
        <canvas id="resultCanvas" style="border: 1px solid #444;"></canvas>
        <p>결과 이미지가 생성되었습니다. 클립보드에 복사되었습니다.</p>
    </div>

    <script>
        // 콘솔 출력을 textarea에 리다이렉트
        const outputElement = document.getElementById('output');
        let outputText = '';

        // 콘솔 메서드 오버라이드
        function redirectConsole(method, prefix = '') {
            const original = console[method];
            console[method] = function(...args) {
                outputText += prefix + args.join(' ') + '\n';
                outputElement.value = outputText;
                outputElement.scrollTop = outputElement.scrollHeight;
                original.apply(console, args);
            };
        }
        
        redirectConsole('log');
        redirectConsole('error', 'ERROR: ');
        redirectConsole('warn', 'WARN: ');

        // 사용자 입력 처리를 위한 전역 변수
        let userInputResolver = null;
        const tileSelect = document.getElementById('tileSelect');
        const selectTileButton = document.getElementById('selectTile');
        const stopSelectionButton = document.getElementById('stopSelection');
        const inputSection = document.getElementById('inputSection');
        const tilePathItems = document.getElementById('tilePathItems');
        
        // 타일 경로를 저장하는 배열
        let currentTilePath = [];

        // 입력 섹션 표시/숨김
        function showInputSection(show) {
            inputSection.style.display = show ? 'block' : 'none';
        }
        
        // 타일 경로 업데이트
        function updateTilePath(tiles) {
            currentTilePath = tiles.slice();
            tilePathItems.innerHTML = '';
            
            if (tiles.length === 0) {
                tilePathItems.innerHTML = '<span style="color: #aaaaaa;">타일 없음</span>';
                return;
            }
            
            tiles.forEach((tile, index) => {
                const tileButton = document.createElement('button');
                tileButton.textContent = String.fromCharCode(65 + (index % 26)); // A, B, C, ...
                tileButton.title = `(${tile.r}, ${tile.c}) - 클릭하여 이 타일부터 삭제`;
                tileButton.style.cssText = `
                    padding: 5px 10px;
                    background-color: #4a4a4a;
                    color: #ffffff;
                    border: 1px solid #666;
                    border-radius: 3px;
                    cursor: pointer;
                    font-weight: bold;
                `;
                
                tileButton.addEventListener('mouseenter', () => {
                    tileButton.style.backgroundColor = '#ff6666';
                });
                
                tileButton.addEventListener('mouseleave', () => {
                    tileButton.style.backgroundColor = '#4a4a4a';
                });
                
                tileButton.addEventListener('click', () => {
                    removeTilesFrom(index);
                });
                
                tilePathItems.appendChild(tileButton);
                
                // 마지막 타일이 아니면 화살표 추가
                if (index < tiles.length - 1) {
                    const arrow = document.createElement('span');
                    arrow.textContent = '→';
                    arrow.style.cssText = 'color: #aaaaaa; margin: 0 2px;';
                    tilePathItems.appendChild(arrow);
                }
            });
        }
        
        // 특정 인덱스부터 타일 삭제
        function removeTilesFrom(index) {
            if (typeof window.removeTilesFromPath === 'function') {
                window.removeTilesFromPath(index);
            } else {
                console.error('removeTilesFromPath function not available');
            }
        }
        
        // 전역으로 노출
        window.updateTilePath = updateTilePath;
        window.showInputSection = showInputSection;

        // 각도를 화살표로 변환하는 함수
        function getArrowFromAngle(deg) {
            const dirs = [
                { a: 0,   ch: "→" },
                { a: 45,  ch: "↗" },
                { a: 90,  ch: "↑" },
                { a: 135, ch: "↖" },
                { a: 180, ch: "←" },
                { a: 225, ch: "↙" },
                { a: 270, ch: "↓" },
                { a: 315, ch: "↘" },
            ];
            let best = dirs[0];
            let bestDiff = 1e9;
            for (const d of dirs) {
                let diff = Math.abs(deg - d.a);
                diff = Math.min(diff, 360 - diff);
                if (diff < bestDiff) { bestDiff = diff; best = d; }
            }
            return best.ch;
        }

        // 타일 선택 옵션 업데이트
        function createTileOption(index, text, color = null) {
            const option = document.createElement('option');
            option.value = index;
            option.textContent = text;
            if (color) option.style.color = color;
            return option;
        }
        
        function updateTileOptions(candidates, tiles, cur, centers, k, prevAngle, adjacentCandidates = []) {
            tileSelect.innerHTML = '';
            
            // '-- 선택 --' 옵션 생성
            const defaultOption = document.createElement('option');
            defaultOption.value = '';
            
            // 선택 가능한 타일이 1개만 있으면 붉은색으로 표시하고 표식 추가
            if (adjacentCandidates?.length === 1) {
                defaultOption.textContent = '⓵ -- 선택 --';
                defaultOption.style.color = '#ff0000';
                // select 요소 자체도 붉은색으로 변경 (닫혀있을 때 보이도록)
                tileSelect.style.color = '#ff0000';
            } else {
                defaultOption.textContent = '-- 선택 --';
                // select 요소 색상을 기본값으로 복원
                tileSelect.style.color = '';
            }
            
            tileSelect.appendChild(defaultOption);
            
            // textarea에 표시할 텍스트 준비
            let textareaInfo = `\n`;
            
            // 타일이 있는 경우 강조 표시
            if (adjacentCandidates?.length >= 1) {
                textareaInfo += `${'='.repeat(50)}\n`;
                textareaInfo += `*** 주의: 선택 가능한 타일이 ${adjacentCandidates.length}개 있습니다! ***\n`;
                textareaInfo += `${'='.repeat(50)}\n`;
            }
            
            textareaInfo += `Available adjacent tiles:\n`;
            
            // 인접 타일 추가
            if (adjacentCandidates?.length > 0) {
                adjacentCandidates.forEach((adjTile, index) => {
                    let text = `${index}. (${adjTile.r}, ${adjTile.c})`;
                    let angleInfo = '';
                    
                    // 각도 정보가 있으면 추가
                    if (adjTile.angle !== undefined) {
                        const arrow = getArrowFromAngle(adjTile.angle);
                        angleInfo = ` - ${adjTile.angle.toFixed(1)}° ${arrow}`;
                        if (adjTile.diff !== null && adjTile.diff !== undefined) {
                            angleInfo += ` (Δ${adjTile.diff.toFixed(1)}°)`;
                        }
                        text += angleInfo;
                    }
                    
                    // 각도가 비슷하면 별표 추가, 아니면 같은 길이의 공백 추가
                    if (adjTile.isPreferred) {
                        text = `★★ ${text}`;
                    } else {
                        text = `    ${text}`;  // 별표 2개와 공백 1개 = 총 4칸 공백
                    }
                    
                    // textarea에 추가
                    textareaInfo += `  ${text}\n`;
                    
                    // select 옵션 생성 (녹색 표시)
                    const displayText = `${index}. (${adjTile.r}, ${adjTile.c})${angleInfo}`;
                    const color = adjTile.isPreferred ? '#00ff00' : null;
                    tileSelect.appendChild(createTileOption(index, displayText, color));
                });
                
                // 타일이 있는 경우 하단에도 강조 표시
                if (adjacentCandidates.length >= 1) {
                    textareaInfo += `${'='.repeat(50)}\n`;
                }
            }
            
            // textarea 업데이트
            // 콘솔 리다이렉션과 동기화하기 위해 outputText에 직접 추가
            if (typeof outputText !== 'undefined') {
                outputText += textareaInfo;
            }
            const outputArea = document.getElementById('output');
            if (outputArea) {
                outputArea.value = outputText || outputArea.value + textareaInfo;
                outputArea.scrollTop = outputArea.scrollHeight;
            }
            
            // select를 기본 옵션으로 리셋
            tileSelect.selectedIndex = 0;
            tileSelect.value = '';
            
            document.getElementById('currentTileInfo').textContent = `현재 타일: (${tiles[cur].r}, ${tiles[cur].c})`;
            
            // 디버깅: 생성된 옵션 로그 출력
            console.log(`Updated tile options: ${tileSelect.options.length} options total`);
            for (let i = 0; i < tileSelect.options.length; i++) {
                console.log(`  Option ${i}: value="${tileSelect.options[i].value}", text="${tileSelect.options[i].text}"`);
            }
        }
        
        // 전역으로 노출
        window.updateTileOptions = updateTileOptions;

        // 버튼 이벤트 리스너
        function handleUserInput(value) {
            console.log(`handleUserInput called with value: "${value}" (type: ${typeof value})`);
            
            // 빈 값 체크 - 경고만 표시하고 계속 대기
            if (value === '' || value === null || value === undefined) {
                console.log('Empty or invalid selection. Please select an option.');
                alert('옵션을 선택해주세요.');
                return; // Promise 계속 대기
            }
            
            // stop은 항상 허용
            if (value === 'stop') {
                console.log(`Special command received: ${value}`);
                if (userInputResolver) {
                    userInputResolver(value);
                    userInputResolver = null;
                }
                return;
            }
            
            // 숫자 선택의 경우 - 옵션 존재 여부와 관계없이 일단 전달
            // JavaScript 코드에서 처리하도록
            console.log(`Resolving with value: "${value}"`);
            if (userInputResolver) {
                userInputResolver(value);
                userInputResolver = null;
            } else {
                console.log('No userInputResolver available.');
            }
        }
        
        selectTileButton.addEventListener('click', () => handleUserInput(tileSelect.value));
        stopSelectionButton.addEventListener('click', () => handleUserInput('stop'));

        // 초기에는 입력 섹션 숨김
        showInputSection(false);
        
        // CTRL-V로 이미지 붙여넣기 처리
        const inputCanvas = document.getElementById('inputCanvas');
        const inputCtx = inputCanvas.getContext('2d');
        const gridLoadStatus = document.getElementById('gridLoadStatus');
        let pastedImage = null;
        let startPos = { x: 0, y: 0 }; // 기본 시작 위치 (0,0)

        document.addEventListener('paste', (e) => {
            const items = Array.from(e.clipboardData.items);
            const imageItem = items.find(item => item.type.indexOf('image') !== -1);
            
            if (imageItem) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => {
                        loadImageOnCanvas(img, '이미지가 캔버스에 로드되었습니다. 시작 위치를 클릭하거나 "이미지에서 그리드 로드" 버튼을 클릭하세요.');
                        saveImageToLocalStorage();
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(imageItem.getAsFile());
            }
        });

        // 이미지 로컬 저장 및 로드
        function saveImageToLocalStorage() {
            try {
                localStorage.setItem('savedImage', inputCanvas.toDataURL('image/png'));
                console.log('이미지가 localStorage에 저장되었습니다.');
            } catch (e) {
                console.error('이미지 저장 실패:', e);
            }
        }

        function loadImageOnCanvas(img, message) {
            inputCanvas.width = Math.min(img.width, 400);
            inputCanvas.height = Math.min(img.height, 400);
            inputCtx.clearRect(0, 0, inputCanvas.width, inputCanvas.height);
            inputCtx.drawImage(img, 0, 0, inputCanvas.width, inputCanvas.height);
            pastedImage = img;
            gridLoadStatus.textContent = message;
        }

        function loadImageFromLocalStorage() {
            try {
                const savedImageData = localStorage.getItem('savedImage');
                if (savedImageData) {
                    const img = new Image();
                    img.onload = () => {
                        loadImageOnCanvas(img, '이전에 저장된 이미지가 자동으로 로드되었습니다.');
                        console.log('localStorage에서 이미지를 불러왔습니다.');
                    };
                    img.src = savedImageData;
                }
            } catch (e) {
                console.error('이미지 불러오기 실패:', e);
            }
        }

        // 페이지 로드 시 이미지 불러오기
        loadImageFromLocalStorage();

        // 캔버스 클릭 이벤트로 시작 위치 지정
        inputCanvas.addEventListener('click', (e) => {
            const rect = inputCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            startPos = { x, y };
            gridLoadStatus.textContent = `시작 위치: (${Math.floor(x)}, ${Math.floor(y)}). "이미지에서 그리드 로드" 버튼을 클릭하세요.`;
            
            inputCtx.beginPath();
            inputCtx.arc(x, y, 5, 0, 2 * Math.PI);
            inputCtx.fillStyle = 'red';
            inputCtx.fill();
        });

        // 이미지에서 그리드 로드 버튼 이벤트
        document.getElementById('loadGridFromImage').addEventListener('click', () => {
            if (!pastedImage) {
                gridLoadStatus.textContent = '이미지가 로드되지 않았습니다. CTRL-V로 이미지를 붙여넣으세요.';
                return;
            }
            
            const newGrid = loadGridFromCanvas(inputCanvas, inputCtx, startPos);
            if (newGrid?.length > 0 && newGrid[0]?.length > 0) {
                window.currentGrid = newGrid;
                gridLoadStatus.textContent = '그리드가 성공적으로 로드되었습니다.';
                console.log('New grid loaded from image:', newGrid);
                if (typeof printGridOnly !== 'undefined') {
                    printGridOnly(newGrid, 'Initial Grid State');
                }
                document.getElementById('startTileCalculation').style.display = 'inline-block';
            } else {
                gridLoadStatus.textContent = '그리드 로드에 실패했습니다. 이미지가 올바른지 확인하세요.';
            }
        });

        // 타일 계산 시작 버튼 이벤트
        document.getElementById('startTileCalculation').addEventListener('click', () => {
            if (!window.currentGrid) {
                gridLoadStatus.textContent = '그리드가 로드되지 않았습니다. 먼저 이미지를 로드하세요.';
                return;
            }
            
            gridLoadStatus.textContent = '타일 배치를 찾고 있습니다.';
            document.getElementById('calculationStatus').style.display = 'block';
            
            const tileSize = parseInt(document.getElementById('tileSizeSelect').value, 10);
            const startPosition = document.getElementById('startPositionSelect').value;
            const startAngle = parseFloat(document.getElementById('startAngleSelect').value);
            
            const startRuleMap = { topLeft: 'topleft', topRight: 'topright', custom: 'custom' };
            const startRule = startRuleMap[startPosition] || 'topleft';
            
            let customStartTile = null;
            if (startRule === 'custom') {
                const r = parseInt(document.getElementById('startTileR').value, 10);
                const c = parseInt(document.getElementById('startTileC').value, 10);
                customStartTile = { r, c };
                console.log(`Custom start tile: (${r}, ${c})`);
            }
            console.log(`Start angle: ${startAngle}°`);
            
            const result = getAllPossiblePlacements(window.currentGrid, tileSize, {
                startRule,
                customStartTile,
                startAngle
            });
            
            document.getElementById('calculationStatus').style.display = 'none';
            
            if (!result.placements || result.placements.length === 0) {
                console.log('No valid tile placements found.');
                return;
            }
            
            window.savedPlacements = result.placements;
            window.savedConfig = { tileSize, startRule, customStartTile, startAngle };
            
            console.log(`Found ${result.placements.length} possible tile placements.`);
            console.log(`Starting with tile at (${result.initialTiles[0].r}, ${result.initialTiles[0].c})`);
            
            // 초기 타일 표시
            printPlacementAscii(window.currentGrid, result.initialTiles, tileSize, '-- Starting Position --');
            if (typeof window.updateTilePath === 'function') {
                window.updateTilePath(result.initialTiles);
            }
            
            // 사용자 선택 모드 시작
            const nextRule = makeNextByWeightedWithMaxDist({ wDist: 1.0, wTurn: 2.5, maxDist: 2.5 });
            const orderingResult = orderTilesWithNextRule(
                result.initialTiles,
                tileSize,
                nextRule,
                startRule,
                120,
                window.currentGrid,
                customStartTile,
                startAngle
            );
            
            if (orderingResult?.state) {
                console.log("Starting manual tile selection...");
                resumeTileOrdering(orderingResult.state, 120, window.savedPlacements, window.currentGrid)
                    .then(result => {
                        if (result?.orderedTiles) {
                            console.log("Tile selection completed. Final tiles:", result.orderedTiles.map(t => `(${t.r},${t.c})`).join(" "));
                        }
                    })
                    .catch(error => console.error("Error during tile selection:", error));
            }
        });
        
        // 첫 타일 위치 선택 시 Custom 옵션에 따라 입력 필드 표시/숨김
        document.getElementById('startPositionSelect').addEventListener('change', () => {
            const startPosition = document.getElementById('startPositionSelect').value;
            document.getElementById('customStartTile').style.display = startPosition === 'custom' ? 'inline-block' : 'none';
        });

        // 캔버스에서 선택된 크기의 그리드를 로드하는 함수
        function loadGridFromCanvas(canvas, ctx, startPos = { x: 0, y: 0 }) {
            const gridSize = parseInt(document.getElementById('gridSizeSelect').value, 10);
            const imgWidth = pastedImage?.width || canvas.width;
            const imgHeight = pastedImage?.height || canvas.height;
            const scaleX = imgWidth / canvas.width;
            const scaleY = imgHeight / canvas.height;
            const imgStartX = startPos.x * scaleX;
            const imgStartY = startPos.y * scaleY;
            
            const grid = [];
            for (let r = 0; r < gridSize; r++) {
                const row = [];
                for (let c = 0; c < gridSize; c++) {
                    const canvasX = (imgStartX + c) / scaleX;
                    const canvasY = (imgStartY + r) / scaleY;
                    
                    if (canvasX >= 0 && canvasX < canvas.width && canvasY >= 0 && canvasY < canvas.height) {
                        const pixelData = ctx.getImageData(Math.floor(canvasX), Math.floor(canvasY), 1, 1).data;
                        const isBlack = pixelData[0] < 50 && pixelData[1] < 50 && pixelData[2] < 50;
                        row.push(isBlack ? 1 : 0);
                    } else {
                        row.push(0);
                    }
                }
                grid.push(row);
            }
            return grid;
        }
    </script>
    <script src="blockMove.js"></script>
</body>
</html>
