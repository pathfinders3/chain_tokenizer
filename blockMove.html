<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Block Move Solver Output</title>
    <link rel="icon" type="image/png" href="blockMove.png">
    <style>
        body {
            font-family: monospace;
            margin: 20px;
            background-color: #1e1e1e;
            color: #ffffff;
        }
        h1 {
            color: #ffffff;
        }
        textarea {
            width: 100%;
            height: 600px;
            font-family: 'Courier New', Courier, monospace;
            font-size: 14px;
            line-height: 1.2;
            background-color: #2d2d2d;
            color: #ffffff;
            border: 1px solid #444;
            padding: 10px;
            resize: vertical;
            white-space: pre;
        }
    </style>
</head>
<body>
    <h1>Block Move Solver Output</h1>
    <div id="inputCanvasContainer" style="margin-bottom: 20px;">
        <p>이미지를 붙여넣으려면 아래 캔버스에 CTRL-V를 사용하세요. 시작 위치를 지정하려면 캔버스를 클릭하세요:</p>
        <canvas id="inputCanvas" width="400" height="400" style="border: 1px solid #444; cursor: crosshair;"></canvas>
        <div style="margin-top: 10px;">
            <label for="gridSizeSelect">그리드 크기 선택:</label>
            <select id="gridSizeSelect">
                <option value="8">8x8</option>
                <option value="16">16x16</option>
            </select>
            <label for="iterationLimitSelect">반복 횟수 제한:</label>
            <select id="iterationLimitSelect">
                <option value="100000">100,000</option>
                <option value="50000">50,000</option>
                <option value="20000">20,000</option>
                <option value="10000">10,000</option>
            </select>
            <label for="depthLimitSelect">깊이 제한:</label>
            <select id="depthLimitSelect">
                <option value="15">15</option>
                <option value="20">20</option>
                <option value="25">25</option>
                <option value="30">30</option>
                <option value="35">35</option>
                <option value="40">40</option>
                <option value="50" selected>50</option>
                <option value="60">60</option>
                <option value="70">70</option>
            </select>
            <p style="font-size: 12px; color: #aaaaaa;">참고: 큰 그리드(16x16 등)에서는 깊이 제한 50 이상을 권장합니다.</p>
            <button id="loadGridFromImage">이미지에서 그리드 로드</button>
            <button id="startTileCalculation" style="display: none;">타일 계산 시작</button>
            <label for="startPositionSelect">첫 타일 위치:</label>
            <select id="startPositionSelect">
                <option value="topLeft">Top-Left</option>
                <option value="topRight">Top-Right</option>
                <option value="custom">Custom</option>
            </select>
            <span id="customStartTile" style="display: none;">
                <label for="startTileR">Row:</label>
                <input type="number" id="startTileR" min="0" value="0" style="width: 60px;">
                <label for="startTileC">Column:</label>
                <input type="number" id="startTileC" min="0" value="1" style="width: 60px;">
            </span>
            <label for="startAngleSelect">시작 각도(방향):</label>
            <select id="startAngleSelect">
                <option value="0">→ (0°, 오른쪽)</option>
                <option value="45">↗ (45°, 오른쪽 위)</option>
                <option value="90">↑ (90°, 위)</option>
                <option value="135">↖ (135°, 왼쪽 위)</option>
                <option value="180">← (180°, 왼쪽)</option>
                <option value="225">↙ (225°, 왼쪽 아래)</option>
                <option value="270">↓ (270°, 아래)</option>
                <option value="315">↘ (315°, 오른쪽 아래)</option>
            </select>
            <label for="tileSizeSelect">타일 크기:</label>
            <select id="tileSizeSelect">
                <option value="2">2x2</option>
                <option value="3">3x3</option>
            </select>
        </div>
        <p id="gridLoadStatus"></p>
        <p id="calculationStatus" style="font-weight: bold; color: #ffff00; display: none;">계산 진행 중입니다. 잠시만 기다려 주세요...</p>
    </div>
    <textarea id="output" readonly>
        계산 중입니다. 잠시만 기다려 주세요...
    </textarea>
    <div id="inputSection" style="margin-top: 20px;">
        <label for="tileSelect">다음 타일을 선택하세요:</label>
        <span id="currentTileInfo" style="margin-left: 10px; font-weight: bold; color: #ffff00;">현재 타일: 없음</span>
        <br>
        <select id="tileSelect">
            <option value="">-- 선택 --</option>
        </select>
        <button id="selectTile">선택</button>
        <button id="autoSelect">자동 선택</button>
        <button id="stopSelection">중지</button>
    </div>
    <div id="canvasContainer" style="margin-top: 20px; display: none;">
        <canvas id="resultCanvas" style="border: 1px solid #444;"></canvas>
        <p>결과 이미지가 생성되었습니다. 클립보드에 복사되었습니다.</p>
    </div>

    <script>
        // 콘솔 출력을 textarea에 리다이렉트
        const outputElement = document.getElementById('output');
        let outputText = '';

        // 콘솔 메서드 오버라이드
        function redirectConsole(method, prefix = '') {
            const original = console[method];
            console[method] = function(...args) {
                outputText += prefix + args.join(' ') + '\n';
                outputElement.value = outputText;
                outputElement.scrollTop = outputElement.scrollHeight;
                original.apply(console, args);
            };
        }
        
        redirectConsole('log');
        redirectConsole('error', 'ERROR: ');
        redirectConsole('warn', 'WARN: ');

        // 사용자 입력 처리를 위한 전역 변수
        let userInputResolver = null;
        const tileSelect = document.getElementById('tileSelect');
        const selectTileButton = document.getElementById('selectTile');
        const autoSelectButton = document.getElementById('autoSelect');
        const stopSelectionButton = document.getElementById('stopSelection');
        const inputSection = document.getElementById('inputSection');

        // 입력 섹션 표시/숨김
        function showInputSection(show) {
            inputSection.style.display = show ? 'block' : 'none';
        }

        // 타일 선택 옵션 업데이트
        function createTileOption(index, text, color = null) {
            const option = document.createElement('option');
            option.value = index;
            option.textContent = text;
            if (color) option.style.color = color;
            return option;
        }
        
        function updateTileOptions(candidates, tiles, cur, centers, k, prevAngle, adjacentCandidates = []) {
            tileSelect.innerHTML = '<option value="">-- 선택 --</option>';
            
            // DFS 타일 추가
            candidates.forEach((cand, index) => {
                const tile = tiles[cand.i];
                const dist = tileDist(centers[cur], centers[cand.i], k);
                const ang = angleDegCart(centers[cur], centers[cand.i]);
                const turn = prevAngle == null ? 0 : angleDiff(prevAngle, ang);
                const text = `${index + 1}. (${tile.r}, ${tile.c}) - Dist: ${dist.toFixed(2)}, Angle: ${ang.toFixed(1)}°, Turn: ${turn.toFixed(1)}°`;
                tileSelect.appendChild(createTileOption(index, text));
            });
            
            // 인접 타일 추가
            if (adjacentCandidates?.length > 0) {
                adjacentCandidates.forEach((adjTile, index) => {
                    const adjIndex = candidates.length + index;
                    const text = `${adjIndex + 1}. [Adj.] (${adjTile.r}, ${adjTile.c})`;
                    tileSelect.appendChild(createTileOption(adjIndex, text, '#00ff00'));
                });
            }
            
            document.getElementById('currentTileInfo').textContent = `현재 타일: (${tiles[cur].r}, ${tiles[cur].c})`;
        }

        // 버튼 이벤트 리스너
        function handleUserInput(value) {
            if (userInputResolver) {
                userInputResolver(value);
                userInputResolver = null;
            }
        }
        
        selectTileButton.addEventListener('click', () => handleUserInput(tileSelect.value));
        autoSelectButton.addEventListener('click', () => handleUserInput('auto'));
        stopSelectionButton.addEventListener('click', () => handleUserInput('stop'));

        // 초기에는 입력 섹션 숨김
        showInputSection(false);
        
        // CTRL-V로 이미지 붙여넣기 처리
        const inputCanvas = document.getElementById('inputCanvas');
        const inputCtx = inputCanvas.getContext('2d');
        const gridLoadStatus = document.getElementById('gridLoadStatus');
        let pastedImage = null;
        let startPos = { x: 0, y: 0 }; // 기본 시작 위치 (0,0)

        document.addEventListener('paste', (e) => {
            const items = Array.from(e.clipboardData.items);
            const imageItem = items.find(item => item.type.indexOf('image') !== -1);
            
            if (imageItem) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => {
                        loadImageOnCanvas(img, '이미지가 캔버스에 로드되었습니다. 시작 위치를 클릭하거나 "이미지에서 그리드 로드" 버튼을 클릭하세요.');
                        saveImageToLocalStorage();
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(imageItem.getAsFile());
            }
        });

        // 이미지 로컬 저장 및 로드
        function saveImageToLocalStorage() {
            try {
                localStorage.setItem('savedImage', inputCanvas.toDataURL('image/png'));
                console.log('이미지가 localStorage에 저장되었습니다.');
            } catch (e) {
                console.error('이미지 저장 실패:', e);
            }
        }

        function loadImageOnCanvas(img, message) {
            inputCanvas.width = Math.min(img.width, 400);
            inputCanvas.height = Math.min(img.height, 400);
            inputCtx.clearRect(0, 0, inputCanvas.width, inputCanvas.height);
            inputCtx.drawImage(img, 0, 0, inputCanvas.width, inputCanvas.height);
            pastedImage = img;
            gridLoadStatus.textContent = message;
        }

        function loadImageFromLocalStorage() {
            try {
                const savedImageData = localStorage.getItem('savedImage');
                if (savedImageData) {
                    const img = new Image();
                    img.onload = () => {
                        loadImageOnCanvas(img, '이전에 저장된 이미지가 자동으로 로드되었습니다.');
                        console.log('localStorage에서 이미지를 불러왔습니다.');
                    };
                    img.src = savedImageData;
                }
            } catch (e) {
                console.error('이미지 불러오기 실패:', e);
            }
        }

        // 페이지 로드 시 이미지 불러오기
        loadImageFromLocalStorage();

        // 캔버스 클릭 이벤트로 시작 위치 지정
        inputCanvas.addEventListener('click', (e) => {
            const rect = inputCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            startPos = { x, y };
            gridLoadStatus.textContent = `시작 위치: (${Math.floor(x)}, ${Math.floor(y)}). "이미지에서 그리드 로드" 버튼을 클릭하세요.`;
            
            inputCtx.beginPath();
            inputCtx.arc(x, y, 5, 0, 2 * Math.PI);
            inputCtx.fillStyle = 'red';
            inputCtx.fill();
        });

        // 이미지에서 그리드 로드 버튼 이벤트
        document.getElementById('loadGridFromImage').addEventListener('click', () => {
            if (!pastedImage) {
                gridLoadStatus.textContent = '이미지가 로드되지 않았습니다. CTRL-V로 이미지를 붙여넣으세요.';
                return;
            }
            
            const newGrid = loadGridFromCanvas(inputCanvas, inputCtx, startPos);
            if (newGrid?.length > 0 && newGrid[0]?.length > 0) {
                window.currentGrid = newGrid;
                gridLoadStatus.textContent = '그리드가 성공적으로 로드되었습니다.';
                console.log('New grid loaded from image:', newGrid);
                if (typeof printGridOnly !== 'undefined') {
                    printGridOnly(newGrid, 'Initial Grid State');
                }
                document.getElementById('startTileCalculation').style.display = 'inline-block';
            } else {
                gridLoadStatus.textContent = '그리드 로드에 실패했습니다. 이미지가 올바른지 확인하세요.';
            }
        });

        // 타일 계산 시작 버튼 이벤트
        document.getElementById('startTileCalculation').addEventListener('click', () => {
            if (!window.currentGrid) {
                gridLoadStatus.textContent = '그리드가 로드되지 않았습니다. 먼저 이미지를 로드하세요.';
                return;
            }
            
            gridLoadStatus.textContent = '타일 계산을 시작합니다.';
            document.getElementById('calculationStatus').style.display = 'block';
            
            const iterationLimit = parseInt(document.getElementById('iterationLimitSelect').value, 10);
            const depthLimit = parseInt(document.getElementById('depthLimitSelect').value, 10);
            const startPosition = document.getElementById('startPositionSelect').value;
            const tileSize = parseInt(document.getElementById('tileSizeSelect').value, 10);
            const startAngle = parseFloat(document.getElementById('startAngleSelect').value);
            
            const startRuleMap = { topLeft: 'topleft', topRight: 'topright', custom: 'custom' };
            const startRule = startRuleMap[startPosition] || 'topleft';
            
            let customStartTile = null;
            if (startRule === 'custom') {
                const r = parseInt(document.getElementById('startTileR').value, 10);
                const c = parseInt(document.getElementById('startTileC').value, 10);
                customStartTile = { r, c };
                console.log(`Custom start tile: (${r}, ${c})`);
            }
            console.log(`Start angle: ${startAngle}°`);
            
            const solutions = printBestTilePlacements(window.currentGrid, tileSize, 1, {
                showVisual: true,
                showDirections: true,
                order: "weighted",
                weighted: { wDist: 1.0, wTurn: 2.5, maxDist: 2.5 },
                maxAngleDiff: 60,
                iterationLimit,
                depthLimit,
                startRule,
                customStartTile,
                startAngle
            });
            
            document.getElementById('calculationStatus').style.display = 'none';
            
            window.savedPlacements = solutions.placements;
            window.savedConfig = { tileSize, iterationLimit, depthLimit, startRule, customStartTile, startAngle };
            window.accumulatedTiles = [];
            
            if (solutions?.[0]?.orderingState) {
                console.log("Resuming tile ordering...");
                resumeTileOrdering(solutions[0].orderingState, 120, window.savedPlacements, window.currentGrid)
                    .then(result => {
                        if (result?.rerunning) {
                            console.log("DFS re-run initiated.");
                        } else if (result?.orderedTiles) {
                            console.log("Ordered tiles:", result.orderedTiles.map(t => `(${t.r},${t.c})`).join(" "));
                        }
                    })
                    .catch(error => console.error("Error resuming tile ordering:", error));
            }
        });
        
        // DFS 재실행 함수 (인접 타일 선택 시)
        window.rerunDFSWithNewTile = function(existingTiles, newTile) {
            window.accumulatedTiles = existingTiles.slice();
            console.log(`Re-running DFS with ${window.accumulatedTiles.length} accumulated tiles: ${window.accumulatedTiles.map(t => `(${t.r},${t.c})`).join(", ")}`);
            
            const config = window.savedConfig;
            const solutions = printBestTilePlacements(window.currentGrid, config.tileSize, 1, {
                showVisual: true,
                showDirections: true,
                order: "weighted",
                weighted: { wDist: 1.0, wTurn: 2.5, maxDist: 2.5 },
                maxAngleDiff: 120,
                iterationLimit: config.iterationLimit,
                depthLimit: config.depthLimit,
                startRule: config.startRule,
                customStartTile: config.customStartTile,
                startAngle: config.startAngle,
                fixedTiles: window.accumulatedTiles
            });
            
            if (solutions?.[0]?.orderingState) {
                console.log(`Resuming after DFS re-run. New solution: ${solutions[0].tiles.length} tiles (${window.accumulatedTiles.length} fixed)`);
                resumeTileOrdering(solutions[0].orderingState, 120, window.savedPlacements, window.currentGrid)
                    .then(result => {
                        if (result?.orderedTiles) {
                            console.log("Ordered tiles:", result.orderedTiles.map(t => `(${t.r},${t.c})`).join(" "));
                        }
                    })
                    .catch(error => console.error("Error resuming:", error));
            } else {
                console.log("DFS could not find additional tiles. Try adjusting depth/iteration limits.");
            }
        };

        // 첫 타일 위치 선택 시 Custom 옵션에 따라 입력 필드 표시/숨김
        document.getElementById('startPositionSelect').addEventListener('change', () => {
            const startPosition = document.getElementById('startPositionSelect').value;
            document.getElementById('customStartTile').style.display = startPosition === 'custom' ? 'inline-block' : 'none';
        });

        // 캔버스에서 선택된 크기의 그리드를 로드하는 함수
        function loadGridFromCanvas(canvas, ctx, startPos = { x: 0, y: 0 }) {
            const gridSize = parseInt(document.getElementById('gridSizeSelect').value, 10);
            const imgWidth = pastedImage?.width || canvas.width;
            const imgHeight = pastedImage?.height || canvas.height;
            const scaleX = imgWidth / canvas.width;
            const scaleY = imgHeight / canvas.height;
            const imgStartX = startPos.x * scaleX;
            const imgStartY = startPos.y * scaleY;
            
            const grid = [];
            for (let r = 0; r < gridSize; r++) {
                const row = [];
                for (let c = 0; c < gridSize; c++) {
                    const canvasX = (imgStartX + c) / scaleX;
                    const canvasY = (imgStartY + r) / scaleY;
                    
                    if (canvasX >= 0 && canvasX < canvas.width && canvasY >= 0 && canvasY < canvas.height) {
                        const pixelData = ctx.getImageData(Math.floor(canvasX), Math.floor(canvasY), 1, 1).data;
                        const isBlack = pixelData[0] < 50 && pixelData[1] < 50 && pixelData[2] < 50;
                        row.push(isBlack ? 1 : 0);
                    } else {
                        row.push(0);
                    }
                }
                grid.push(row);
            }
            return grid;
        }
    </script>
    <script src="blockMove.js"></script>
</body>
</html>
